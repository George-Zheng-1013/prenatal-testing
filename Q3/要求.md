下面给出一套**可直接落地**的“多因素条件下两阶段法（早测 + 复测）”来求解**问题三**中“按 BMI 分组后各组最佳 NIPT 时点”的完整方法。它严格对齐赛题约束：检测窗 10–25 周、以 Y 浓度≥4% 为“达标”，并对 12 周以内/13–27 周/28 周以后设置不同风险等级（早/中/晚）。

---

# 1. 核心对象与符号

* 记第 g 个  **BMI 组** （后文第 4 节讲如何得到）为 g=1,…,Gg=1,\dots,G。
* Fg(t)F_g(t)：在孕周 tt 时，该组“Y 浓度≥4%（达标）”的 **达标比例** （或“完成率”）——来自 **多因素概率模型** （第 2 节）。
* 两阶段策略 (t0,t1)(t_0, t_1)：先在 t0t_0 首测；若未达标/不判定，则在 t1>t0t_1>t_0 复测。候选范围 t0,t1∈[10,25]t_0,t_1\in[10,25]（单位：周）。
* 约束：Fg(t1)≥πmin⁡F_g(t_1)\ge \pi_{\min}（例如 85%/90%/95%），“总体覆盖”要足够高；对  **晚期** （≥28 周）检测视为 **极高风险** （应避免）。

---

# 2. 多因素达标比例引擎 Fg(t)F_g(t)

## 2.1 目标

给定一个 BMI 组 gg 与孕周 tt，估计**组内达标比例** Fg(t)F_g(t)。

## 2.2 训练数据与特征

* 记录级别：一次采血 = 一条记录；同一孕妇可多次记录。
* **标签** ：hit=1{Y_conc≥0.04}\texttt{hit}=1\{Y\_\text{conc}\ge 0.04\}。
* **特征（多因素）** ：孕周 tt、BMI、年龄、身高、体重、IVF 指标、测序质量（读段数、比对率、重复率、唯一比对数、样本 GC、各染色体 GC、过滤比例等）。
* **质控** ：剔除极端劣质样本；同时**保留**质量变量以“入模或加权”，避免把“技术噪声”误判为“生物学延迟”。

## 2.3 建模方式（给两条可选主线）

* **AFT（区间删失）/离散时间 hazard** ：更严谨，围绕“**最早达标时间 **T^\*)**”建模，天然得到 \(F_g(t)=\Pr(T^\*\le t)**。
* **判别式概率模型** （与你现有 `c3.py` 一致）：用多因素分类器（如 RF/GBDT/Logit）学习 Pr⁡(hit=1∣X,t)\Pr(\texttt{hit}=1\mid X,t)。将“孕周强制设为 tt”后对组内样本求均值，即

  Fg(t)≈1∣g∣∑i∈gPr⁡^(hiti=1∣Xi, t).F_g(t)\approx \frac{1}{|g|}\sum_{i\in g}\widehat{\Pr}(\texttt{hit}_i=1\mid X_i,\,t).
  这就是 `predict_attainment_probability()` → `calculate_group_attainment_rate()` 的思想。

> 实操建议：若时间有限，沿用你们 `c3.py` 的概率模型引擎即可；若追求严格统计解释，可把“多次检测”整成区间删失数据改用 AFT/离散 hazard，但对下游优化接口不变（仍然只需要 Fg(t)F_g(t)）。

---

# 3. 两阶段的 **评价函数** （选最优 (t0,t1)(t_0,t_1)）

你需要把“尽早完成、覆盖要高、避免中晚期、控制复测量、考虑检测误差”统一成一个**可优化**的目标。给出两个常用版本： **期望完成时间（ET）**与**期望风险/成本（R）** 。二者都以 Fg(t)F_g(t) 为输入。

## 3.1 期望完成时间（ET，越小越好）

一次两阶段完成的 **期望时间** ：

ETg(t0,t1)=t0⋅Fg(t0)  +  t1⋅(Fg(t1)−Fg(t0))  +  τ⋅(1−Fg(t1)).\mathrm{ET}_g(t_0,t_1)=t_0\cdot F_g(t_0)\;+\;t_1\cdot\big(F_g(t_1)-F_g(t_0)\big)\;+\;\tau\cdot \big(1-F_g(t_1)\big).

* 解释：
  * 以 t0t_0 完成的比例是 Fg(t0)F_g(t_0)；
  * 以 t1t_1 完成（首测未成、复测完成）的比例是 Fg(t1)−Fg(t0)F_g(t_1)-F_g(t_0)；
  * 到 t1t_1 仍未完成的比例 1−Fg(t1)1-F_g(t_1) 赋予**惩罚时间** τ\tau（可取 25–26 周或再加一层晚期惩罚）。
* **硬约束** ：Fg(t1)≥πmin⁡F_g(t_1)\ge \pi_{\min}。
* **可加软约束** ：若 Fg(t1)<πmin⁡F_g(t_1)<\pi_{\min} 则罚 γ⋅(πmin⁡−Fg(t1))\gamma\cdot(\pi_{\min}-F_g(t_1))。

## 3.2 期望风险/成本（R，越小越好）

把赛题的**早/中/晚**风险（≤12低、13–27高、≥28极高）和“失败/复测/误差”揉成加权成本：

Rg(t0,t1)=ct0⏟时间段成本 at t0⋅(1−Fg(t0))  +  ct1⏟时间段成本 at t1⋅(Fg(t1)−Fg(t0))+  clate⋅1(t1≥28)  +  cmid⋅1(13≤t0≤27)+  cretest⋅(1−Fg(t0))  +  cshort⋅(πmin⁡−Fg(t1))++  cerr⋅MEg(t0,t1).\begin{aligned}
\mathrm{R}_g(t_0,t_1)=&\underbrace{c_{t_0}}_{\text{时间段成本 at }t_0}\cdot \big(1-F_g(t_0)\big)\;+\;\underbrace{c_{t_1}}_{\text{时间段成本 at }t_1}\cdot \big(F_g(t_1)-F_g(t_0)\big)\\
&+\;c_{\mathrm{late}}\cdot\mathbf{1}(t_1\ge 28)\;+\;c_{\mathrm{mid}}\cdot\mathbf{1}(13\le t_0\le 27)\\
&+\;c_{\mathrm{retest}}\cdot \big(1-F_g(t_0)\big)\;+\;c_{\mathrm{short}}\cdot(\pi_{\min}-F_g(t_1))_+\\
&+\;c_{\mathrm{err}}\cdot \mathrm{ME}_g(t_0,t_1).
\end{aligned}

* ctc_{t} 可取 {cearly,cmid,clate}\{c_{\mathrm{early}},c_{\mathrm{mid}},c_{\mathrm{late}}\} 中之一（按 t 落在哪个区间），体现“13–27 周高、≥28 周极高”。
* cretestc_{\mathrm{retest}}：复测带来的流程/资源成本，按“首测未成比例 1−Fg(t0)1-F_g(t_0)”加权。
* cshortc_{\mathrm{short}}：覆盖不足惩罚。
* MEg(⋅)\mathrm{ME}_g(\cdot)：**测量误差/不可判定**项，简化可设 MEg=eˉg⋅(1−Fg(t1))\mathrm{ME}_g = \bar e_g\cdot\big(1-F_g(t_1)\big)；更细可由质量特征训练一个“no-call 概率”模型并用逆概率加权（IPW）修正。
* 仍施加硬约束：Fg(t1)≥πmin⁡F_g(t_1)\ge \pi_{\min}（或转成上式软惩罚）。

> 实操口径：若要“更早为先、只要够覆盖”，用 **ET** 更直观；若要体现“时间分区风险 + 复测/误差成本”，用 **R** 更灵活。两者都能并列汇报，互为印证。赛题文本对“时间窗与风险等级”的要求为本节权重设计提供了依据。

---

# 4. “先多因素、后回归到 BMI”的**分组**策略

* 训练 Fg(t)F_g(t) 时充分利用多因素（BMI、年龄、身高、体重、IVF、质量…）。
* **但最终只输出 BMI 分组** ：
* **首选** ： **监督式最优分箱** （以“在 t\*t^\* 周是否达标/或 T\*≤t\*T^\*\le t^\*”为监督信号，对 BMI 做单调约束分箱，设置每组最小样本/最小阳性数），3–5 组；
* **备选** ：浅层可解释树读取 BMI 切点；或像 `c3.py` 那样先尝试等频/聚类，再以总体期望成本择优。
* 产出每组 gg 的 BMI 区间 [bg,min⁡,bg,max⁡][b_{g,\min}, b_{g,\max}]。

---

# 5. **网格搜索**求解每组的 (t0g,t1g)(t_0^g,t_1^g)

## 5.1 搜索域

* t0∈{10,10.5,…,20}t_0 \in \{10,10.5,\dots,20\}（也可步长 0.25–0.5 周）；
* t1∈{t0+0.5,…,25}t_1 \in \{t_0+0.5,\dots,25\}；
* 可选：若想进一步降低晚期风险，限制 t1≤26t_1\le 26。

## 5.2 计算流程

对每个 BMI 组 gg：

1. 预先缓存 Fg(t)F_g(t) 的 **查表** （避免重复算）：对每个候选 tt 批量调用引擎 `predict_attainment_probability→mean` 得到 Fg(t)F_g(t)。
2. 双重循环枚举 (t0,t1)(t_0,t_1)：
   * 若设  **ET** ：计算 ETg(t0,t1)\mathrm{ET}_g(t_0,t_1)；
   * 若设  **R** ：计算 Rg(t0,t1)\mathrm{R}_g(t_0,t_1)。
3. 应用 **硬约束** ：若 Fg(t1)<πmin⁡F_g(t_1)<\pi_{\min}，直接丢弃或强罚。
4. 记录最优 arg⁡min⁡\arg\min 的 (t0g,t1g)(t_0^g,t_1^g) 与相应指标（Fg(t0g),Fg(t1g)F_g(t_0^g),F_g(t_1^g)、复测率 1−Fg(t0g)1-F_g(t_0^g)、ET 或 R）。

> 若想加速，可对 t0t_0 先筛选：仅考虑 Fg(t0)≥ρmin⁡F_g(t_0)\ge \rho_{\min}（如 0.5–0.6），减少不必要的复测负担。

## 5.3 参考伪代码（与你的 `c3.py` 风格一致）

```python
def two_stage_search(group_df, pi_min=0.90, metric="ET",
                     step0=0.5, step1=0.5, late_cap=26, tau=25,
                     cw=dict(early=1, mid=3, late=10, retest=2, short=50, err=5)):
    # 1) 预计算F_g(t)
    T0 = np.arange(10, 20 + 1e-9, step0)
    T1 = np.arange(10.5, 25 + 1e-9, step1)
    F = {t: calc_group_attain_rate(group_df, t) for t in np.union1d(T0, T1)}

    best = None
    for t0 in T0:
        for t1 in T1[T1 > t0]:
            if late_cap is not None and t1 > late_cap:  # 可选硬限制
                continue
            if F[t1] < pi_min:                          # 覆盖硬约束
                continue

            if metric == "ET":
                val = t0 * F[t0] + t1 * (F[t1] - F[t0]) + tau * (1 - F[t1])
            else:
                c0 = cw['early'] if t0 <= 12 else (cw['mid'] if t0 <= 27 else cw['late'])
                c1 = cw['early'] if t1 <= 12 else (cw['mid'] if t1 <= 27 else cw['late'])
                val = (c0 * (1 - F[t0]) + c1 * (F[t1] - F[t0])
                       + cw['retest'] * (1 - F[t0])
                       + cw['short'] * max(0.0, pi_min - F[t1])
                       + (cw['late'] if t1 >= 28 else 0.0))

            if (best is None) or (val < best['val']):
                best = dict(t0=t0, t1=t1, val=val,
                            F0=F[t0], F1=F[t1], retest_rate=1 - F[t0])
    return best
```

---

# 6. **统计不确定性**与**稳健性**

* **Bootstrap（以孕妇为抽样单位）** ：重复抽样 B 次（如 500），每次重算 Fg(t)F_g(t) 与最优 (t0g,t1g)(t_0^g,t_1^g)，给出 t0,t1,F0,F1t_0,t_1,F_0,F_1 的 95% CI。
* **敏感性分析** ：
* πmin⁡∈{0.85,0.90,0.95}\pi_{\min}\in\{0.85,0.90,0.95\}；
* 评价函数：ET vs R；
* 权重 cc 的不同取值（尤其是 clate≫cmidc_{\mathrm{late}}\gg c_{\mathrm{mid}}）；
* 误差项 ME\mathrm{ME} 的不同刻画（全局常数 vs 质量驱动的个体化）。
* **校准图** ：预测曲线 Fg(t)F_g(t) 与经验 Turnbull/KM 在各 BMI 组上的对比，验证模型与数据一致性。

---

# 7. 报告输出（论文可直接用的表格/图）

* **表 1（BMI 分组表）** ：区间（min,max）、样本数、组内均值（BMI、年龄、身高、体重）。
* **表 2（单次 vs 两阶段）** ：每组的
* 单次最优 tgt_g 与 Fg(tg)F_g(t_g)；
* 两阶段最优 (t0g,t1g)(t_0^g,t_1^g)、Fg(t0g),Fg(t1g)F_g(t_0^g),F_g(t_1^g)、复测率、ET 或 R；
* 是否触及 13/28 周边界（标注风险等级）。
* **图 1** ：各组 Fg(t)F_g(t) 曲线与 95% 置信带。
* **图 2** ：两阶段最优 (t0g,t1g)(t_0^g,t_1^g) 的热力/等高线（横轴 t0t_0、纵轴 t1t_1、颜色为 ET 或 R）。
* **图 3** ：不同 πmin⁡\pi_{\min} 与权重设置下的敏感性对比条形/雷达图。

---

# 8. 与你现有代码（`c3.py`）如何对接

你们现成的单阶段流程已经具备：

* 多因素概率模型 → 组达标率 Fg(t)F_g(t)（`predict_attainment_probability` / `calculate_group_attainment_rate`）；
* 单阶段评价函数（`calculate_multifactor_risk`）与一维网格（`optimize_group_testing_time`）；
* 分组策略与敏感性分析管线。

 **只需新增一个二维网格器** （第 5.3 节伪代码），并把 **ET** 与 **R** 两个目标函数实现成可选项（沿用你们的“早/中/晚”权重即可），就能得到 **两阶段最优 (t0,t1)(t_0,t_1)** 。整个管线、可视化与落盘脚本基本不变，只是多写两列输出（t0,t1t_0,t_1 与复测率/ET/R）。赛题的窗口与风险分段要求，正是本方法的约束与权重来源。

---

## 小结

* 用多因素模型估 Fg(t)F_g(t)，再在每个 BMI 组上做两阶段 (t0,t1)(t_0,t_1) 的 **网格搜索** ，以 **ET** 或 **R** 为目标，配合“覆盖率 πmin⁡\pi_{\min}”硬/软约束与“早/中/晚”分段权重，即可得到 **最佳 NIPT 时点** （单次与两阶段并报）。
* 该框架与赛题条件完全一致（10–25 周可测；Y≥4% 作为判定阈值；晚期风险极高；要求按 BMI 给出分组与最佳时点）。

如果你愿意，我可以把上面的二维网格函数直接按你们 `c3.py` 的接口写成一段 **可粘贴** 的实现（含参数化权重与导出字段名），让你们直接加入现有工程跑出结果表图。
